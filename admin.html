<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tournament Admin Panel</title>
    <style>
        /* General Body and Container Styling */
        body {
            font-family: sans-serif;
            margin: 0; /* Changed from 20px to 0 for full edge-to-edge on mobile */
            background-color: #f4f4f4;
            color: #333;
            line-height: 1.6; /* Added for better readability */
        }
        .container {
            max-width: 900px;
            margin: auto;
            background: #fff;
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        /* Headings */
        h1, h2 {
            color: #333;
            border-bottom: 2px solid #eee;
            padding-bottom: 10px;
            margin-top: 30px;
            font-size: 1.8em; /* Adjusted for better mobile scaling */
        }
        h2 {
            font-size: 1.5em; /* Adjusted for better mobile scaling */
        }

        /* Form Styling */
        form {
            margin-bottom: 25px;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #f9f9f9;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #555;
        }
        input[type="text"], input[type="date"], input[type="time"], input[type="number"], select {
            width: calc(100% - 22px);
            padding: 10px;
            margin-bottom: 15px;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box; /* Include padding in width */
            font-size: 1em; /* Ensures input text is readable */
        }
        input[type="text"][readonly] {
            background-color: #e9e9e9;
            cursor: not-allowed;
        }

        /* Button Styling */
        button {
            background-color: #007bff;
            color: white;
            padding: 10px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin-right: 10px;
            transition: background-color 0.2s;
            display: inline-block; /* Ensure buttons behave correctly in flex on larger screens */
            width: auto; /* Reset width for larger screens */
        }
        button:hover {
            background-color: #0056b3;
        }
        button.delete {
            background-color: #dc3545;
        }
        button.delete:hover {
            background-color: #c82333;
        }

        /* Message Styling */
        .message {
            margin-top: 15px;
            padding: 10px;
            border-radius: 4px;
            font-weight: bold;
            display: none; /* Hidden by default */
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }
        .message.show {
            display: block;
            opacity: 1;
        }
        .message.success {
            background-color: #d4edda;
            color: #155724;
            border-color: #c3e6cb;
            box-shadow: 0 0 8px rgba(30, 200, 70, 0.2); /* Green glow */
        }
        .message.error {
            background-color: #f8d7da;
            color: #721c24;
            border-color: #f5c6cb;
            box-shadow: 0 0 8px rgba(220, 50, 50, 0.2); /* Red glow */
        }

        /* Flex Container Styling */
        .flex-container {
            display: flex;
            flex-wrap: wrap; /* Allows items to wrap to next line on smaller screens */
            gap: 20px;
            margin-bottom: 20px;
        }
        .flex-item {
            flex: 1; /* Allows items to grow and shrink */
            min-width: 250px; /* Ensures items don't get too small before wrapping */
        }

        /* Loading Spinner Styles (No changes needed, already responsive) */
        #loadingSpinner {
            display: none;
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            z-index: 1000;
            background: rgba(255, 255, 255, 0.8);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 15px rgba(0,0,0,0.2);
            text-align: center;
        }
        #loadingSpinner img {
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* --- Mobile Responsiveness --- */
        @media (max-width: 768px) {
            /* Body and Container adjustments */
            body {
                margin: 0; /* Ensure no external margin */
            }
            .container {
                padding: 15px; /* Slightly less padding on smaller screens */
                margin: 10px; /* Add some margin from the screen edges */
                box-shadow: none; /* Remove box shadow for a cleaner mobile look */
            }

            /* Heading adjustments */
            h1 {
                font-size: 1.5em; /* Smaller font size for main heading */
            }
            h2 {
                font-size: 1.2em; /* Smaller font size for subheadings */
            }

            /* Flex container behavior */
            .flex-container {
                flex-direction: column; /* Stack items vertically */
                gap: 10px; /* Reduce gap between stacked items */
            }
            .flex-item {
                min-width: unset; /* Remove min-width when stacked */
                width: 100%; /* Ensure flex items take full width when stacked */
            }

            /* Form element adjustments */
            input[type="text"], input[type="date"], input[type="time"], input[type="number"], select {
                width: 100%; /* Full width on small screens */
                padding: 10px; /* Keep consistent padding */
                margin-bottom: 10px; /* Standard margin for vertical stacking */
                font-size: 1em; /* Keep readable font size */
            }

            /* Button adjustments */
            button {
                width: calc(100% - 20px); /* Full width buttons with padding consideration */
                margin-bottom: 10px; /* Add margin between stacked buttons */
                margin-right: 0; /* Remove right margin when stacked */
                padding: 12px 15px; /* Slightly more vertical padding for easier tapping */
                box-sizing: border-box; /* Include padding in width */
            }
            button.delete {
                margin-bottom: 0; /* No margin if it's the last button in a group */
            }
        }

        /* Further refinement for very small screens */
        @media (max-width: 480px) {
            .container {
                padding: 10px; /* Even less padding on very small screens */
                margin: 5px; /* Smaller margin for very small screens */
            }

            h1 {
                font-size: 1.3em;
            }
            h2 {
                font-size: 1.1em;
            }

            form {
                padding: 15px; /* Slightly less padding inside forms */
            }

            /* Reduce input/select padding slightly if needed, but 10px is usually good */
            input[type="text"], input[type="date"], input[type="time"], input[type="number"], select {
                padding: 8px;
            }
        }
    </style>
</head>
<body>
    <div id="loginContainer" class="container" style="display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 100vh; text-align: center;">
        <h2>Admin Login</h2>
        <form id="loginForm" style="width: 100%; max-width: 300px; padding: 20px; border: 1px solid #ddd; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.05); background-color: #f9f9f9;">
            <div style="margin-bottom: 15px;">
                <label for="usernameInput" style="display: block; margin-bottom: 5px; font-weight: bold; text-align: left;">Username:</label>
                <input type="text" id="usernameInput" required style="width: calc(100% - 22px); padding: 10px; border: 1px solid #ccc; border-radius: 4px;">
            </div>
            <div style="margin-bottom: 20px;">
                <label for="passwordInput" style="display: block; margin-bottom: 5px; font-weight: bold; text-align: left;">Password:</label>
                <input type="password" id="passwordInput" required style="width: calc(100% - 22px); padding: 10px; border: 1px solid #ccc; border-radius: 4px;">
            </div>
            <button type="submit" style="background-color: #4CAF50; color: white; padding: 10px 20px; border: none; border-radius: 4px; cursor: pointer; font-size: 1em;">Login</button>
            <p id="loginMessage" style="color: red; margin-top: 15px;"></p>
        </form>
    </div>

    <div id="adminPanelContent" class="container" style="display: none;">
        <h1>Tournament Admin Panel</h1>

        <div id="loadingSpinner">
            <img src="https://upload.wikimedia.org/wikipedia/commons/b/b1/Loading_icon.gif" alt="Loading...">
            <p>Loading data...</p>
        </div>

        <h2>Live Match Update</h2>
        <form id="liveScoreForm">
            <div class="flex-container">
                <div class="flex-item">
                    <label for="livescoreCategory">Category:</label>
                    <select id="livescoreCategory"></select>
                </div>
                <div class="flex-item">
                    <label for="livescoreStage">Stage:</label>
                    <select id="livescoreStage"></select>
                </div>
                <div class="flex-item">
                    <label for="livescoreGroup">Group:</label>
                    <select id="livescoreGroup"></select>
                </div>
            </div>
            
            <div class="flex-container">
                <div class="flex-item">
                    <label for="livescoreSelectBy">Select By:</label>
                    <select id="livescoreSelectBy">
                        <option value="matchId">Match ID</option>
                        <option value="teamName">Team Name Pair</option> </select>
                </div>
                <div class="flex-item" id="livescoreTeamSelectionContainer">
                    <div id="livescoreTeamPairSelection" style="display: none;">
                        <label for="livescoreSelectedTeam1">Team 1 Name:</label>
                        <select id="livescoreSelectedTeam1"></select>

                        <label for="livescoreSelectedTeam2">Team 2 Name:</label>
                        <select id="livescoreSelectedTeam2"></select>
                    </div>
                </div>
                <div class="flex-item">
                     <label for="livescoreMatchId">Match ID:</label>
                     <select id="livescoreMatchId"></select>
                </div>
            </div>
            
            <label for="livescoreTeam1Name">Team 1 Name:</label>
            <input type="text" id="livescoreTeam1Name" readonly>
        
            <label for="livescoreTeam2Name">Team 2 Name:</label>
            <input type="text" id="livescoreTeam2Name" readonly>

            <label for="livescoreTeam1Score">Team 1 Score:</label>
            <input type="number" id="livescoreTeam1Score" min="0">

            <label for="livescoreTeam2Score">Team 2 Score:</label>
            <input type="number" id="livescoreTeam2Score" min="0">

            <label for="livescoreStatus">Status:</label>
            <select id="livescoreStatus">
                <option value="Scheduled">Scheduled</option>
                <option value="In Progress">In Progress</option>
                <option value="Completed">Completed</option>
            </select>
            <label for="livescoreCourt">Court:</label>
            <input type="text" id="livescoreCourt" placeholder="Court Number or Name">
            <div style="margin-bottom: 15px; margin-top: 10px;">
                <input type="checkbox" id="superAdminModeCheckbox">
                <label for="superAdminModeCheckbox" style="display: inline-block; font-weight: normal;">Super Admin Mode (Bypass Completed Match Lock)</label>
            </div>
            <button type="submit"  id="updateLiveScoreButton">Update Live Score</button>
            <div id="liveScoreMessage" class="message"></div>
        </form>

        <h2>Fixture Management</h2>
        <form id="fixtureForm">
            <label for="fixtureAction">Action:</label>
            <select id="fixtureAction">
                <option value="update">Update Existing Fixture</option>
                <option value="create">Create New Fixture</option>
                <option value="delete">Delete Fixture</option>
            </select>
            
            <div class="flex-container">
                <div class="flex-item">
                    <label for="fixtureCategory">Category:</label>
                    <select id="fixtureCategory"></select>
                </div>
                <div class="flex-item">
                    <label for="fixtureStage">Stage:</label>
                    <select id="fixtureStage"></select>
                </div>
                <div class="flex-item">
                    <label for="fixtureGroup">Group:</label>
                    <select id="fixtureGroup"></select>
                </div>
            </div>
            
            <label for="fixtureMatchId">Match ID:</label>
            <select id="fixtureMatchId"></select>
            <input type="text" id="fixtureIdInput" placeholder="Auto-generate or enter new ID" readonly>
            <div id="matchIdGenerationOptions" style="display: none; margin-bottom: 15px;">
                <label>Match ID:</label><br>
                <input type="radio" id="autoGenerateMatchId" name="matchIdOption" value="auto" checked>
                <label for="autoGenerateMatchId">Auto-generate</label>
                <input type="radio" id="manualMatchId" name="matchIdOption" value="manual">
                <label for="manualMatchId">Manually Enter</label>
            </div>


            <label for="fixtureTeam1Input">Team 1:</label>
            <select id="fixtureTeam1Input"></select>

            <label for="fixtureTeam2Input">Team 2:</label>
            <select id="fixtureTeam2Input"></select>

            <label for="fixtureCourtSelect">Court:</label>
            <input type="text" id="fixtureCourtSelect" placeholder="Court Number or Name">
            
            <label for="fixtureTimeInput">Time:</label>
            <input type="time" id="fixtureTimeInput">

            <label for="fixtureDateInput">Date:</label>
            <input type="date" id="fixtureDateInput">

            <label for="fixtureStatusSelect">Status:</label>
            <select id="fixtureStatusSelect">
                <option value="Scheduled">Scheduled</option>
                <option value="In Progress">In Progress</option>
                <option value="Completed">Completed</option>
            </select>

            <button type="submit" id="fixtureSubmitButton">Update Fixture</button>
            <button type="button" id="clearFixtureFormButton" class="delete">Clear Form</button>
            <div id="fixtureMessage" class="message"></div>
        </form>
    </div>

    <script>
        // --- Client-Side Password Protection ---
        const CORRECT_USERNAME = 'admin'; // <--- CHANGE THIS USERNAME
        const CORRECT_PASSWORD = 'password123'; // <--- CHANGE THIS PASSWORD
        // Define a client-side password for the super admin mode (NOT SECURE FOR PRODUCTION)
        const SUPER_ADMIN_CLIENT_PASSWORD = 'pass123';

        const loginContainer = document.getElementById('loginContainer');
        const loginForm = document.getElementById('loginForm');
        const usernameInput = document.getElementById('usernameInput');
        const passwordInput = document.getElementById('passwordInput');
        const loginMessage = document.getElementById('loginMessage');
        const adminPanelContent = document.getElementById('adminPanelContent');

        // Function to show/hide sections
        function showAdminPanel() {
            loginContainer.style.display = 'none';
            adminPanelContent.style.display = 'block';
            // Store login status in session storage
            sessionStorage.setItem('isLoggedIn', 'true');
            // Now that we're logged in, fetch data and initialize the panel
            fetchAllData();
            fixtureActionSelect.dispatchEvent(new Event('change')); // Initialize fixture form
        }

        function showLoginForm() {
            loginContainer.style.display = 'flex'; // Use flex to center
            adminPanelContent.style.display = 'none';
            sessionStorage.removeItem('isLoggedIn'); // Clear login status
        }

        // Handle login form submission
        loginForm.addEventListener('submit', (e) => {
            e.preventDefault(); // Prevent default form submission

            const enteredUsername = usernameInput.value;
            const enteredPassword = passwordInput.value;

            if (enteredUsername === CORRECT_USERNAME && enteredPassword === CORRECT_PASSWORD) {
                loginMessage.textContent = '';
                showAdminPanel();
            } else {
                loginMessage.textContent = 'Invalid username or password.';
                passwordInput.value = ''; // Clear password field
            }
        });

        // Check login status on page load
        document.addEventListener('DOMContentLoaded', () => {
            if (sessionStorage.getItem('isLoggedIn') === 'true') {
                showAdminPanel();
            } else {
                showLoginForm();
            }
        });

        // Global variables to store fetched data
        let allFixtures = [];
        let allLiveMatches = [];
        let allTeamNames = []; // To store unique team names for fixture dropdowns

        // Loading spinner elements
        const loadingSpinner = document.getElementById('loadingSpinner');

        function showLoading() {
            loadingSpinner.style.display = 'block';
        }

        function hideLoading() {
            loadingSpinner.style.display = 'none';
        }

        // Helper function to get unique values from an array of objects
        function getUniqueValues(data, key) {
            return [...new Set(data.map(item => item[key]))].filter(Boolean).sort();
        }

        // Helper to populate select dropdowns
        function populateSelect(selectElement, options, currentValue = null, skipChangeEvent = false, autoSelectIfSingle = false) {
            selectElement.innerHTML = ''; // Clear existing options
            const defaultOption = document.createElement('option');
            defaultOption.value = '';
            defaultOption.textContent = '-- Select --';
            selectElement.appendChild(defaultOption);

            options.forEach(option => {
                const opt = document.createElement('option');
                opt.value = option;
                opt.textContent = option;
                if (currentValue && option === currentValue) {
                    opt.selected = true;
                }
                selectElement.appendChild(opt);
            });

            // Auto-select if only one option after populating (excluding the default '-- Select --')
            if (autoSelectIfSingle && options.length === 1) {
                selectElement.value = options[0];
            }

            if ((currentValue || (autoSelectIfSingle && options.length === 1)) && !skipChangeEvent) {
                // Manually trigger change event if a value is set programmatically or auto-selected
                selectElement.dispatchEvent(new Event('change'));
            }
        }

        // --- Message Display Function ---
        function displayMessage(element, message, type) {
            element.textContent = message;
            element.classList.remove('success', 'error', 'show'); // Always remove these for a clean state
            if (type) { // Only add type class if it's not empty
                element.classList.add(type);
            }
            element.classList.add('show'); // Make visible
            setTimeout(() => {
                element.classList.remove('show'); // Hide after some time
                // Clear text after transition for cleaner re-use
                setTimeout(() => element.textContent = '', 300); 
            }, 5000); // Message visible for 5 seconds
        }

        // New function to load match data into the live score form fields
        function loadLiveScoreFormData(selectedMatch) {
                currentSelectedLiveMatch = selectedMatch; // Set the global variable

                if (selectedMatch) {
                    livescoreTeam1NameInput.value = selectedMatch['Team 1'] || '';
                    livescoreTeam2NameInput.value = selectedMatch['Team 2'] || '';
                    livescoreTeam1ScoreInput.value = selectedMatch['Team 1 Score'] || 0;
                    livescoreTeam2ScoreInput.value = selectedMatch['Team 2 Score'] || 0;
                    livescoreStatusSelect.value = selectedMatch['Status'] || 'Scheduled';
                    livescoreCourtInput.value = selectedMatch['Court'] || '';
                } else {
                    // Clear the form fields if no match is selected (or resetting)
                    livescoreTeam1NameInput.value = '';
                    livescoreTeam2NameInput.value = '';
                    livescoreTeam1ScoreInput.value = '';
                    livescoreTeam2ScoreInput.value = '';
                    livescoreStatusSelect.value = 'Scheduled';
                    livescoreCourtInput.value = '';
                    superAdminModeCheckbox.checked = false; // Also reset the super admin checkbox
                }
                // Always apply restrictions after loading/clearing data
                applyLiveScoreFormRestrictions();
            }


        // --- Live Score Section Elements ---
        const livescoreCategorySelect = document.getElementById('livescoreCategory');
        const livescoreStageSelect = document.getElementById('livescoreStage');
        const livescoreGroupSelect = document.getElementById('livescoreGroup');
        const livescoreSelectBy = document.getElementById('livescoreSelectBy');
        const livescoreMatchIdSelect = document.getElementById('livescoreMatchId');
        
        // NEW elements for Team Name Pair selection
        const livescoreTeamSelectionContainer = document.getElementById('livescoreTeamSelectionContainer');
        const livescoreTeamPairSelection = document.getElementById('livescoreTeamPairSelection');
        const livescoreSelectedTeam1Select = document.getElementById('livescoreSelectedTeam1');
        const livescoreSelectedTeam2Select = document.getElementById('livescoreSelectedTeam2');

        const livescoreTeam1ScoreInput = document.getElementById('livescoreTeam1Score');
        const livescoreTeam2ScoreInput = document.getElementById('livescoreTeam2Score');
        const livescoreStatusSelect = document.getElementById('livescoreStatus');
        const livescoreCourtInput = document.getElementById('livescoreCourt');
        const livescoreTeam1NameInput = document.getElementById('livescoreTeam1Name');
        const livescoreTeam2NameInput = document.getElementById('livescoreTeam2Name');
        const liveScoreMessage = document.getElementById('liveScoreMessage');
        const liveScoreForm = document.getElementById('liveScoreForm');
        const updateLiveScoreButton = document.getElementById('updateLiveScoreButton');
        const superAdminModeCheckbox = document.getElementById('superAdminModeCheckbox');

        let currentSelectedLiveMatch = null; // Global to store the currently loaded match for checks

        // --- Fixture Management Section Elements ---
        const fixtureActionSelect = document.getElementById('fixtureAction');
        const fixtureCategorySelect = document.getElementById('fixtureCategory');
        const fixtureStageSelect = document.getElementById('fixtureStage');
        const fixtureGroupSelect = document.getElementById('fixtureGroup');
        const fixtureMatchIdSelect = document.getElementById('fixtureMatchId');
        const fixtureIdInput = document.getElementById('fixtureIdInput'); // For create mode
        const fixtureTeam1Select = document.getElementById('fixtureTeam1Input'); // Changed to select
        const fixtureTeam2Select = document.getElementById('fixtureTeam2Input'); // Changed to select
        // Removed: fixtureTeam1ScoreInput and fixtureTeam2ScoreInput
        const fixtureCourtSelect = document.getElementById('fixtureCourtSelect');
        const fixtureTimeInput = document.getElementById('fixtureTimeInput');
        const fixtureDateInput = document.getElementById('fixtureDateInput');
        const fixtureStatusSelect = document.getElementById('fixtureStatusSelect');
        const fixtureSubmitButton = document.getElementById('fixtureSubmitButton');
        const fixtureMessage = document.getElementById('fixtureMessage');
        const fixtureForm = document.getElementById('fixtureForm');
        const clearFixtureFormButton = document.getElementById('clearFixtureFormButton');
        const matchIdGenerationOptions = document.getElementById('matchIdGenerationOptions');
        const autoGenerateMatchIdRadio = document.getElementById('autoGenerateMatchId');
        const manualMatchIdRadio = document.getElementById('manualMatchId');

        // IMPORTANT: REPLACE THIS WITH YOUR ACTUAL DEPLOYED GOOGLE APPS SCRIPT WEB APP URL
        const webAppUrl = 'https://script.google.com/macros/s/AKfycbzwzWVhd0HCRjSFEEVhNgpdHQIA1HMbEj21ef3WdhR3641ZAf-0OLoD_Jmeb1oY5NqvCA/exec'; // REPLACE THIS
        
        // Predefined options for fixture dropdowns
        const fixtureCategories = ['Mens Beginner Doubles', 'Mens Advanced Doubles', 'Womens Doubles', 'Mixed Doubles'];
        const fixtureGroups = ['Overall', 'Group A', 'Group B', 'Group C', 'Group D']; // All possible groups
        const fixtureStages = ['League', 'Quarter Finals', 'Semi Finals', 'Final'];
        const fixtureStatuses = ['Scheduled', 'In Progress', 'Completed'];


        // --- Core Data Fetching Function ---
        async function sendRequest(sheetName, id, data, messageElement, action = 'update') {
            showLoading();
            messageElement.classList.remove('success', 'error', 'show'); // Clear previous messages
            messageElement.textContent = '';
            
            // Construct payload for form submission
            const payload = {
                action: action,
                sheet: sheetName,
                id: id,
                ...data 
            };
            console.log("data:", data);            
            console.log("payload:", payload);
            try {
                const response = await fetch(webAppUrl, {
                    method: 'POST',
                    redirect: 'follow',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded', 
                    },
                    mode: 'cors',
                    body: new URLSearchParams(payload).toString() // <--- Use URLSearchParams for form data
                });
                console.log("payload response", response);
                const result = await response.json();
                console.log("payload response result", result);
                hideLoading();

                if (result.status === 'success') {
                    displayMessage(messageElement, result.message, 'success');
                    if (action === 'create' && sheetName === 'Fixtures') {
                        await fetchAllData(id); // Pass the newly created ID
                    } else {
                        await fetchAllData(); // Regular refresh
                    }
                    return true;
                } else {
                    throw new Error(result.message || 'Unknown error');
                }
            } catch (error) {
                hideLoading();
                displayMessage(messageElement, `Error: ${error.message}`, 'error');
                console.error('Request failed:', error);
                return false;
            }
        }

        // --- Initial data fetch on page load ---
        async function fetchAllData(newlyCreatedFixtureId = null) {
            showLoading();
            try {
                // Fetch Fixtures data
                const fixturesResponse = await fetch(`${webAppUrl}?sheet=Fixtures`, { method: 'GET', mode: 'cors' });
                const fixturesData = await fixturesResponse.json();
                if (fixturesData.error) throw new Error(fixturesData.error);
                allFixtures = fixturesData.data.fixtures;

                // Fetch Livescores data
                const liveMatchesResponse = await fetch(`${webAppUrl}?sheet=Livescores`, { method: 'GET', mode: 'cors' });
                const liveMatchesData = await liveMatchesResponse.json();
                if (liveMatchesData.error) throw new Error(liveMatchesData.error);
                allLiveMatches = liveMatchesData.data.liveMatches;

                // Extract all unique team names from fixtures
                const teams1 = getUniqueValues(allFixtures, 'Team 1');
                const teams2 = getUniqueValues(allFixtures, 'Team 2');
                allTeamNames = [...new Set([...teams1, ...teams2])].filter(Boolean).sort();

                console.log("Fetched Fixtures:", allFixtures);
                console.log("Fetched Livescores:", allLiveMatches);
                console.log("All Team Names:", allTeamNames);


                populateLiveScoreDropdowns();
                populateFixtureDropdowns(null, null, null, newlyCreatedFixtureId);

                hideLoading();
            } catch (error) {
                console.error('Error fetching all data:', error);
                displayMessage(liveScoreMessage, 'Error loading data: ' + error.message, 'error');
                displayMessage(fixtureMessage, 'Error loading data: ' + error.message, 'error');
                hideLoading();
            }
        }

        // --- Live Score Functions ---
        // Added selectedTeam1 and selectedTeam2 parameters for filtering by team pair
        function populateLiveScoreDropdowns(selectedCategory = null, selectedStage = null, selectedGroup = null, selectedMatchId = null, selectedTeam1 = null, selectedTeam2 = null) {
            const currentSelectBy = livescoreSelectBy.value;

            const categories = getUniqueValues(allLiveMatches, 'Category');
            populateSelect(livescoreCategorySelect, categories, selectedCategory, true);

            let filteredMatches = allLiveMatches;
            if (selectedCategory) filteredMatches = filteredMatches.filter(m => m.Category === selectedCategory);
            const stages = getUniqueValues(filteredMatches, 'Stage');
            populateSelect(livescoreStageSelect, stages, selectedStage, true);

            if (selectedStage) filteredMatches = filteredMatches.filter(m => m.Stage === selectedStage);
            const groups = getUniqueValues(filteredMatches, 'Group');
            populateSelect(livescoreGroupSelect, groups, selectedGroup, true);

            if (selectedGroup) filteredMatches = filteredMatches.filter(m => m.Group === selectedGroup);

            // Sort filtered matches: In Progress first, then by Match ID descending
            filteredMatches.sort((a, b) => {
                if (a.Status === 'In Progress' && b.Status !== 'In Progress') return -1;
                if (a.Status !== 'In Progress' && b.Status === 'In Progress') return 1;
                return (b['Match ID'] || '').localeCompare(a['Match ID'] || '');
            });


            if (currentSelectBy === 'matchId') {
                livescoreMatchIdSelect.style.display = 'block';
                livescoreTeamPairSelection.style.display = 'none'; // Hide the team pair selection

                const matchIds = getUniqueValues(filteredMatches, 'Match ID');
                populateSelect(livescoreMatchIdSelect, matchIds, selectedMatchId, false, true); // Auto-select if single
                
                // Always fill form based on selected livescoreMatchIdSelect value
                if (livescoreMatchIdSelect.value) {
                    fillLiveScoreForm(livescoreMatchIdSelect.value);
                } else {
                    clearLiveScoreForm();
                }

            } else if (currentSelectBy === 'teamName') { // Now handles Team Name Pair
                livescoreMatchIdSelect.style.display = 'block'; 
                livescoreTeamPairSelection.style.display = 'block'; // Show the team pair selection

                // Populate Team 1 dropdown
                const teamNamesForSelects = allTeamNames; // Use all unique teams for selection
                populateSelect(livescoreSelectedTeam1Select, teamNamesForSelects, selectedTeam1, true);

                // Populate Team 2 dropdown (filter out selected Team 1 if any)
                let availableTeam2Options = teamNamesForSelects;
                if (livescoreSelectedTeam1Select.value) {
                    availableTeam2Options = teamNamesForSelects.filter(team => team !== livescoreSelectedTeam1Select.value);
                }
                populateSelect(livescoreSelectedTeam2Select, availableTeam2Options, selectedTeam2, true);


                let matchesToDisplay = [];
                const team1Selected = livescoreSelectedTeam1Select.value;
                const team2Selected = livescoreSelectedTeam2Select.value;

                if (team1Selected && team2Selected) {
                    // Filter for matches involving specific Team 1 AND Team 2
                    matchesToDisplay = filteredMatches.filter(m => 
                        (m['Team 1'] === team1Selected && m['Team 2'] === team2Selected) ||
                        (m['Team 2'] === team1Selected && m['Team 1'] === team2Selected) // Account for reverse order
                    );
                } else if (team1Selected) {
                    // Filter for matches involving specific Team 1 (as either Team 1 or Team 2)
                    matchesToDisplay = filteredMatches.filter(m => 
                        m['Team 1'] === team1Selected || m['Team 2'] === team1Selected
                    );
                } else if (team2Selected) {
                    // Filter for matches involving specific Team 2 (as either Team 1 or Team 2)
                    matchesToDisplay = filteredMatches.filter(m => 
                        m['Team 1'] === team2Selected || m['Team 2'] === team2Selected
                    );
                }
                // If neither is selected, matchesToDisplay will be empty, which is intended behavior (no match IDs shown)

                // Populate Match ID dropdown with filtered results
                const matchIdsToPopulate = getUniqueValues(matchesToDisplay, 'Match ID');
                populateSelect(livescoreMatchIdSelect, matchIdsToPopulate, null, false, true);

                if (livescoreMatchIdSelect.value) {
                    fillLiveScoreForm(livescoreMatchIdSelect.value);
                } else {
                    clearLiveScoreForm();
                }
            }
        }
        function clearLiveScoreForm() {
            livescoreTeam1ScoreInput.value = '';
            livescoreTeam2ScoreInput.value = '';
            livescoreStatusSelect.value = 'Scheduled'; // Default status
            livescoreCourtInput.value = '';
            livescoreTeam1NameInput.value = ''; // Clear team 1 name
            livescoreTeam2NameInput.value = ''; // Clear team 2 name
            superAdminModeCheckbox.checked = false; // Reset checkbox on clear
            applyLiveScoreFormRestrictions(); // Re-apply restrictions after clearing
        }

        function fillLiveScoreForm(matchId) {
            const match = allLiveMatches.find(m => m['Match ID'] === matchId);
            if (match) {
                livescoreTeam1ScoreInput.value = match['Team 1 Score'] || '';
                livescoreTeam2ScoreInput.value = match['Team 2 Score'] || '';
                livescoreStatusSelect.value = match.Status || 'Scheduled';
                livescoreCourtInput.value = match.Court || '';
                
                livescoreTeam1NameInput.value = match['Team 1'] || ''; // Auto-populate Team 1 Name
                livescoreTeam2NameInput.value = match['Team 2'] || ''; // Auto-populate Team 2 Name
                
                currentSelectedLiveMatch = match; // Update global current selected match
            } else {
                clearLiveScoreForm();
            }
            applyLiveScoreFormRestrictions(); // Apply restrictions based on newly loaded match
        }
        function applyLiveScoreFormRestrictions() {
                const isCompleted = currentSelectedLiveMatch && currentSelectedLiveMatch.Status === 'Completed';
                const isSuperAdmin = superAdminModeCheckbox.checked;

                // Disable/enable fields based on status and super admin mode
                livescoreTeam1ScoreInput.disabled = isCompleted && !isSuperAdmin;
                livescoreTeam2ScoreInput.disabled = isCompleted && !isSuperAdmin;
                livescoreStatusSelect.disabled = isCompleted && !isSuperAdmin;
                livescoreCourtInput.disabled = isCompleted && !isSuperAdmin;
                updateLiveScoreButton.disabled = isCompleted && !isSuperAdmin;

                if (isCompleted && !isSuperAdmin) {
                    updateLiveScoreButton.textContent = 'Match Completed (Super Admin Only)';
                    // Only display if there's no existing error message that's more critical
                    if (!liveScoreMessage.classList.contains('error')) {
                        displayMessage(liveScoreMessage, 'This match is completed. Only Super Admins can make changes.', 'error');
                    }
                } else {
                    updateLiveScoreButton.textContent = 'Update Live Score';
                    // Only clear message if it's the "completed" message. Other error messages should persist.
                    if (liveScoreMessage.textContent.includes('This match is completed') || liveScoreMessage.textContent.includes('Super Admin Mode enabled')) {
                        liveScoreMessage.classList.remove('show');
                        liveScoreMessage.textContent = '';
                    }
                }
            }

        // Add event listener for the Super Admin Mode checkbox
        superAdminModeCheckbox.addEventListener('change', () => {
            if (superAdminModeCheckbox.checked) {
                const enteredPassword = prompt('Please enter the Super Admin password to enable this mode:');
                if (enteredPassword === SUPER_ADMIN_CLIENT_PASSWORD) {
                    displayMessage(liveScoreMessage, 'Super Admin Mode enabled.', 'success');
                    applyLiveScoreFormRestrictions();
                } else {
                    displayMessage(liveScoreMessage, 'Incorrect Super Admin password.', 'error');
                    superAdminModeCheckbox.checked = false; // Uncheck if password is wrong
                    applyLiveScoreFormRestrictions();
                }
            } else {
                // Only clear message if it's the "Super Admin Mode enabled" message
                if (liveScoreMessage.textContent.includes('Super Admin Mode enabled')) {
                    liveScoreMessage.classList.remove('show'); // Hide immediately
                    liveScoreMessage.textContent = ''; // Clear text
                }
                applyLiveScoreFormRestrictions(); // Re-apply restrictions after disabling
            }
        });
        // Event listeners for Live Score Section
        livescoreCategorySelect.addEventListener('change', () => populateLiveScoreDropdowns(livescoreCategorySelect.value, null, null, null, livescoreSelectedTeam1Select.value, livescoreSelectedTeam2Select.value));
        livescoreStageSelect.addEventListener('change', () => populateLiveScoreDropdowns(livescoreCategorySelect.value, livescoreStageSelect.value, null, null, livescoreSelectedTeam1Select.value, livescoreSelectedTeam2Select.value));
        livescoreGroupSelect.addEventListener('change', () => populateLiveScoreDropdowns(livescoreCategorySelect.value, livescoreStageSelect.value, livescoreGroupSelect.value, null, livescoreSelectedTeam1Select.value, livescoreSelectedTeam2Select.value));
        
        // Event listener for "Select By" (Match ID / Team Name)
        livescoreSelectBy.addEventListener('change', () => {
            // Call populateLiveScoreDropdowns to re-filter and re-populate based on new selectBy method
            // Passing current category/stage/group to maintain filters
            populateLiveScoreDropdowns(
                livescoreCategorySelect.value,
                livescoreStageSelect.value,
                livescoreGroupSelect.value,
                null, // Clear matchId
                null, // Clear team1 for new selection mode
                null  // Clear team2 for new selection mode
            );
            
            // Clear the form and re-apply restrictions whenever selectBy changes
            loadLiveScoreFormData(null); // This clears the form and resets currentSelectedLiveMatch
        });

            // Event listener for Live Score Match ID selection
        livescoreMatchIdSelect.addEventListener('change', () => {
            const selectedMatchId = livescoreMatchIdSelect.value;
            const selectedMatch = allLiveMatches.find(match => match['Match ID'] === selectedMatchId);
            
            // Use the new helper function to load data and apply restrictions
            loadLiveScoreFormData(selectedMatch); 
        });

        // NEW Event Listeners for livescoreSelectedTeam1 and livescoreSelectedTeam2
        livescoreSelectedTeam1Select.addEventListener('change', () => {
            populateLiveScoreDropdowns(
                livescoreCategorySelect.value,
                livescoreStageSelect.value,
                livescoreGroupSelect.value,
                null, // Clear selectedMatchId
                livescoreSelectedTeam1Select.value, // Pass current Team 1
                livescoreSelectedTeam2Select.value // Pass current Team 2
            );
        });

        livescoreSelectedTeam2Select.addEventListener('change', () => {
            populateLiveScoreDropdowns(
                livescoreCategorySelect.value,
                livescoreStageSelect.value,
                livescoreGroupSelect.value,
                null, // Clear selectedMatchId
                livescoreSelectedTeam1Select.value, // Pass current Team 1
                livescoreSelectedTeam2Select.value // Pass current Team 2
            );
        });


        liveScoreForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            liveScoreMessage.classList.remove('success', 'error', 'show'); // Clear previous messages
            liveScoreMessage.textContent = ''; // Clear text

            const matchId = livescoreMatchIdSelect.value;
            if (!matchId) {
                displayMessage(liveScoreMessage, 'Please select a Match ID.', 'error');
                return;
            }
            if (currentSelectedLiveMatch && currentSelectedLiveMatch.Status === 'Completed' && !superAdminModeCheckbox.checked) {
                displayMessage(liveScoreMessage, 'Cannot update a completed match without Super Admin Mode enabled.', 'error');
                return; // Prevent submission
            }

            const updates = {
                'Team 1 Score': livescoreTeam1ScoreInput.value,
                'Team 2 Score': livescoreTeam2ScoreInput.value,
                'Status': livescoreStatusSelect.value,
                'Court': livescoreCourtInput.value,
                // Include current category, stage, group for robust backend filtering if needed
                'Category': livescoreCategorySelect.value,
                'Stage': livescoreStageSelect.value,
                'Group': livescoreGroupSelect.value
            };
            
            await sendRequest('Livescores', matchId, updates, liveScoreMessage, 'update');
        });

        // --- Fixture Management Functions ---
        function populateFixtureDropdowns(selectedCategory = null, selectedStage = null, selectedGroup = null, selectedMatchId = null) {
            // Populate static dropdowns with predefined options
            populateSelect(fixtureCategorySelect, fixtureCategories, selectedCategory, true);
            populateSelect(fixtureStageSelect, fixtureStages, selectedStage, true);
            populateSelect(fixtureStatusSelect, fixtureStatuses, null, true); // Status is not dependent

            // Filter existing fixtures based on selections to populate match ID dropdown
            let filteredFixtures = allFixtures;
            if (selectedCategory)   filteredFixtures = filteredFixtures.filter(f => f.Category === selectedCategory);
            if (selectedStage) filteredFixtures = filteredFixtures.filter(f => f.Stage === selectedStage);
            
            // Populate Group dropdown with all possible groups as per original intent (not strictly cascading)
            populateSelect(fixtureGroupSelect, fixtureGroups, selectedGroup, true);

            if (selectedGroup) filteredFixtures = filteredFixtures.filter(f => f.Group === selectedGroup);

            const matchIds = getUniqueValues(filteredFixtures, 'Match ID');
            populateSelect(fixtureMatchIdSelect, matchIds, selectedMatchId, true, true); // Don't trigger change event here

            // Populate Team 1 and Team 2 dropdowns with all unique team names
            populateSelect(fixtureTeam1Select, allTeamNames);
            populateSelect(fixtureTeam2Select, allTeamNames);


            // After populating dropdowns, ensure action change event is triggered
            handleFixtureActionChange();
            if (!selectedMatchId && fixtureMatchIdSelect.value === '') { // Only clear if nothing is selected and no ID was passed
                 // Modified: Only clear if not in auto-generate create mode
                if (!(fixtureActionSelect.value === 'create' && autoGenerateMatchIdRadio.checked)) {
                    clearFixtureForm();
                }
            }
        }

        function clearFixtureForm() {
            fixtureIdInput.value = '';
            fixtureTeam1Select.value = '';
            fixtureTeam2Select.value = '';
            fixtureCourtSelect.value = '';
            fixtureTimeInput.value = '';
            fixtureDateInput.value = '';
            fixtureStatusSelect.value = 'Scheduled'; // Default status
            // Reset Match ID generation to auto-generate
            autoGenerateMatchIdRadio.checked = true;
            manualMatchIdRadio.checked = false;
            fixtureIdInput.readOnly = true; // Ensure it's read-only for auto-generate
            // handleFixtureActionChange(); // This call caused a stack overflow, removed
        }

        function fillFixtureForm(matchId) {
            const fixture = allFixtures.find(f => f['Match ID'] === matchId);
            if (fixture) {
                fixtureCategorySelect.value = fixture.Category || '';
                fixtureStageSelect.value = fixture.Stage || '';
                fixtureGroupSelect.value = fixture.Group || '';
                
                // Populate team name dropdowns based on selected fixture, ensuring cascading
                const team1 = fixture['Team 1'] || '';
                const team2 = fixture['Team 2'] || '';
                populateSelect(fixtureTeam1Select, allTeamNames, team1, true); // Populate with all teams, then select
                
                // For Team 2, filter out Team 1 if Team 1 is selected
                const availableTeam2Options = team1 ? allTeamNames.filter(team => team !== team1) : allTeamNames;
                populateSelect(fixtureTeam2Select, availableTeam2Options, team2, true);

                fixtureCourtSelect.value = fixture.Court || '';
                fixtureTimeInput.value = fixture.Time || '';
                fixtureDateInput.value = fixture.Date || '';
                fixtureStatusSelect.value = fixture.Status || 'Scheduled';
                fixtureIdInput.value = fixture['Match ID'] || ''; // For display in update mode
            } else {
                clearFixtureForm();
            }
        }

        // Generate new Match ID based on Category
        function generateNewMatchId(category) {
            let prefix = '';
            switch (category) {
                case 'Mens Beginner Doubles': prefix = 'MB-'; break; // Changed to hyphen
                case 'Mens Advanced Doubles': prefix = 'MA-'; break; // Changed to hyphen
                case 'Womens Doubles': prefix = 'W-'; break;     // Changed to hyphen
                case 'Mixed Doubles': prefix = 'MD-'; break;     // Changed to hyphen
                default: return `FIX-${Date.now().toString().slice(-6)}`; // Fallback with hyphen
            }

            // Find the highest existing number for this category
            const existingIds = allFixtures
                .map(f => f['Match ID'])
                .filter(id => id.startsWith(prefix))
                .map(id => parseInt(id.replace(prefix, '').trim()))
                .filter(num => !isNaN(num));

            const nextNumber = existingIds.length > 0 ? Math.max(...existingIds) + 1 : 1;
            return `${prefix}${nextNumber}`;
        }


        function handleFixtureActionChange() {
            const actionType = fixtureActionSelect.value;
            const isCreate = actionType === 'create';
            const isDelete = actionType === 'delete';

            fixtureMatchIdSelect.style.display = isCreate ? 'none' : 'block';
            
            fixtureIdInput.style.display = isCreate ? 'block' : 'none'; // Show/hide fixtureIdInput
            matchIdGenerationOptions.style.display = isCreate ? 'block' : 'none'; // Show/hide radio buttons

            if (isCreate) {
                fixtureMatchIdSelect.value = ''; // Ensure no match is selected in the regular dropdown

                if (autoGenerateMatchIdRadio.checked) {
                    fixtureIdInput.readOnly = true; // Make it read-only
                    fixtureIdInput.value = generateNewMatchId(fixtureCategorySelect.value);
                } else { // manualMatchIdRadio.checked
                    fixtureIdInput.readOnly = false; // Make it editable
                    // If previously auto-generated, clear it for manual entry
                    if (fixtureIdInput.value.startsWith('MB-') || fixtureIdInput.value.startsWith('MA-') || fixtureIdInput.value.startsWith('W-') || fixtureIdInput.value.startsWith('MD-') || fixtureIdInput.value.startsWith('FIX-')) {
                         fixtureIdInput.value = '';
                    }
                }
            } else { // Not create mode (update/delete)
                fixtureIdInput.value = ''; // Clear ID input when not in create mode
                fixtureIdInput.readOnly = true; // Should always be read-only in update/delete
                
                // If switching from create to update/delete, try to select the first match ID
                // Only if the match ID select has options other than the default '-- Select --'
                if (fixtureMatchIdSelect.options.length > 1 && fixtureMatchIdSelect.value === '') {
                     fixtureMatchIdSelect.value = fixtureMatchIdSelect.options[1].value;
                     fillFixtureForm(fixtureMatchIdSelect.value);
                } else if (fixtureMatchIdSelect.options.length <= 1) { // No actual matches
                    clearFixtureForm();
                } else { // Keep the current selection if valid
                    fillFixtureForm(fixtureMatchIdSelect.value);
                }
            }

            // Disable or enable fields based on action type
            const fieldsToToggle = [
                fixtureTeam1Select, fixtureTeam2Select, fixtureCourtSelect,
                fixtureTimeInput, fixtureDateInput, fixtureStatusSelect
            ];

            fieldsToToggle.forEach(field => {
                field.disabled = isDelete; // Disable for delete, enable for create/update
            });

            // Adjust button text
            fixtureSubmitButton.textContent = actionType === 'create' ? 'Create Fixture' :
                                             actionType === 'delete' ? 'Delete Fixture' : 'Update Fixture';

            // No need to clear form here, it's handled by specific logic paths
        }


        // Event Listeners for Fixture Section
        fixtureActionSelect.addEventListener('change', handleFixtureActionChange);
        fixtureCategorySelect.addEventListener('change', () => {
            populateFixtureDropdowns(fixtureCategorySelect.value, null, null, null);
            // Re-evaluate ID generation if in create mode and auto-generate is checked
            if (fixtureActionSelect.value === 'create' && autoGenerateMatchIdRadio.checked) {
                fixtureIdInput.value = generateNewMatchId(fixtureCategorySelect.value);
            }
        });
        // MODIFIED: Added logic to re-generate Match ID when Stage or Group changes
        fixtureStageSelect.addEventListener('change', () => {
            populateFixtureDropdowns(fixtureCategorySelect.value, fixtureStageSelect.value, null, null);
            if (fixtureActionSelect.value === 'create' && autoGenerateMatchIdRadio.checked) {
                fixtureIdInput.value = generateNewMatchId(fixtureCategorySelect.value); // Re-generate based on category
            }
        });

        // MODIFIED: Added logic to re-generate Match ID when Stage or Group changes
        fixtureGroupSelect.addEventListener('change', () => {
            populateFixtureDropdowns(fixtureCategorySelect.value, fixtureStageSelect.value, fixtureGroupSelect.value, null);
            if (fixtureActionSelect.value === 'create' && autoGenerateMatchIdRadio.checked) {
                fixtureIdInput.value = generateNewMatchId(fixtureCategorySelect.value); // Re-generate based on category
            }
        });        
        fixtureMatchIdSelect.addEventListener('change', () => fillFixtureForm(fixtureMatchIdSelect.value));

        // Cascading Team Name Dropdowns
        fixtureTeam1Select.addEventListener('change', () => {
            const selectedTeam1 = fixtureTeam1Select.value;
            const availableTeam2Options = selectedTeam1 ? allTeamNames.filter(team => team !== selectedTeam1) : allTeamNames;
            populateSelect(fixtureTeam2Select, availableTeam2Options, fixtureTeam2Select.value, false); // Keep current Team2 if still valid
        });
        // No specific change event needed for fixtureTeam2Select beyond its initial population by Team1.


        clearFixtureFormButton.addEventListener('click', clearFixtureForm);
        // --- NEW LISTENERS FOR MATCH ID GENERATION OPTIONS ---
        autoGenerateMatchIdRadio.addEventListener('change', handleFixtureActionChange);
        manualMatchIdRadio.addEventListener('change', handleFixtureActionChange);
        // --- END NEW LISTENERS ---

        fixtureForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const actionType = fixtureActionSelect.value;
            let targetId;
            let updates = {};

            if (actionType === 'create') {
                targetId = fixtureIdInput.value; // Get auto-generated ID or user-modified one
                if (!targetId || targetId.trim() === '' || targetId.startsWith('New ID')) { // Check for actual ID vs placeholder
                    displayMessage(fixtureMessage, 'Please ensure a valid Match ID is set for creation.', 'error');
                    return;
                }
                updates['Match ID'] = targetId; // Include Match ID for creation
            } else {
                targetId = fixtureMatchIdSelect.value;
                if (!targetId) {
                    displayMessage(fixtureMessage, 'Please select a Match ID to update or delete.', 'error');
                    return;
                }
            }

            if (actionType !== 'delete') {
                updates = {
                    'Category': fixtureCategorySelect.value,
                    'Stage': fixtureStageSelect.value,
                    'Group': fixtureGroupSelect.value,
                    'Team 1': fixtureTeam1Select.value, // Changed to Select
                    'Team 2': fixtureTeam2Select.value, // Changed to Select
                    'Court': fixtureCourtSelect.value,
                    'Time': fixtureTimeInput.value,
                    'Date': fixtureDateInput.value,
                    'Status': fixtureStatusSelect.value
                };
            }

            // Basic validation for required fields for a new entry
            if (actionType === 'create') {
                const requiredFields = ['Category', 'Stage', 'Group', 'Team 1', 'Team 2', 'Court', 'Time', 'Date', 'Status'];
                for (const field of requiredFields) {
                    if (!updates[field] || String(updates[field]).trim() === '') {
                        displayMessage(fixtureMessage, `Please fill all required fields for a new fixture. Missing: ${field.replace('Team 1', 'Team 1 (selection)').replace('Team 2', 'Team 2 (selection)')}`, 'error');
                        return;
                    }
                }
                // Check if the generated/entered ID is truly unique for creation
                const existingFixtureIds = allFixtures.map(f => f['Match ID']);
                if (existingFixtureIds.includes(targetId)) {
                    displayMessage(fixtureMessage, `Match ID "${targetId}" already exists. Please choose a different one or switch to 'Update' mode.`, 'error');
                    return;
                }
            }

            await sendRequest('Fixtures', targetId, updates, fixtureMessage, actionType);
        });

        // --- Initial data fetch on page load ---
        fetchAllData();

        // Initial setup for fixture form based on default action (usually 'update')
        fixtureActionSelect.dispatchEvent(new Event('change'));

    </script>
</body>
</html>